\chapter{SQLAlchemy}

\section{Allgemeines}

SQLAlchemy\footnote{\href{http://www.sqlalchemy.org}{http://www.sqlalchemy.org}}
ist nicht nur ein ORM-System sondern eine Datenbankabstraktionsebene die auch
ORM kann - man kann es auch problemlos nutzen ohne auch nur ein einziges Objekt
zu mappen.

Das Framework besteht aus drei großen Modulen: \textbf{Dialects}, \textbf{Core}
und \textbf{ORM}.

Das \textbf{Dialects}-Modul ist dafür zuständig, auf die verschiedenen
Datenbanksysteme zuzugreifen - eine vollständige Liste der Datenbanksysteme und
der verschiedenen APIs (für MSSQL\footnote{Microsoft SQL Server} gibt es
beispielsweise 5 verschiedene APIs) findet man in der
SQLAlchemy-Dokumentation\footnote{\href
{http://www.sqlalchemy.org/docs/core/engines.html\#supported-dbapis}
{http://www.sqlalchemy.org/docs/core/engines.html\#supported-dbapis}}.
Er abstrahiert also den Zugriff auf die
verschiedenen Datenbanken vollständig, sodass anders als bei Pythons BB-API
abgesehen von den Verbindungsdaten keine unterschiedlichen Funktionsparameter
notwendig sind. Eine weitere Aufgabe des \emph{Dialects}-Moduls ist die
Abstraktion der Spaltentypen - die meisten Datenbanksystemen haben zusätzliche
Typen die nicht standardisiert sind; so hat PostgreSQL beispielsweise den
\emph{INET}-Datentyp um IP-Adressen zu speichern - dieser wird durch
\texttt{postgresql.INET} aus \texttt{sqlalchemy.dialects} repräsentiert.

Das \textbf{Core}-Modul enthält alle nicht-ORM-bezogenen Funktionen von
SQLAlchemy. Dazu gehört insbesondere die \emph{SQL Expression Language}, die dem
Entwickler ermöglicht, SQL zu erzeugen ohne selbst SQL zu schreiben, indem sie
die Bestandteile von SQL durch datenbanksystemunabhängige Python-Konstrukte
repräsentiert. Dabei ist es sowohl möglich, nur die Python-Konstrukte zu
benutzen oder einen String mit einer SQL-Abfrage zu übergeben, als auch beides
zu kombinieren. Die beiden letzteren Methoden sind allerdings u.U. nicht mehr
mit allen Datenbanksystemen kompatibel da man nicht ausschließlich die
Abstraktion benutzt sondern (teilweise) selbst SQL-Abfragen schreibt. Ein
weiterer wichtiger Teil vom \emph{Core} ist der Verbindungsaufbau anhand eines
Connectionstrings, der alle benötigten Daten einschließlich Datenbanksystem und
-API enthält. Ebenfalls vom \emph{Core} zur Verfügung gestellt wird der
Connection-Pool, der bereits aufgebaute Datenbankverbindungen enthält sodass
eine Applikation schnell an eine Verbindung kommt ohne erst eine neue Verbindung
aufbauen zu müssen, was je nach Datenbanksystem ein relativ "teurer" Prozess
ist.

Das dritte und wichtigste Modul ist das \textbf{ORM}-Modul. Im Gegensatz zum
Lowlevel-Zugriff den die \emph{SQL Expression Language} bietet ist das ORM auf
einer hohen Ebene angesiedelt und bietet eine starke Abstraktion. Dazu bietet es
verschiedene Möglichkeiten, Datenbanktabellen und Objekte miteinander zu
verbinden - zum einen den \emph{mapper} umd zum anderen die \emph{declarative
syntax}. Ebenfalls im \emph{ORM}-Modul enthalten ist die
\emph{\texttt{relationship()} API}, mit der man Relationen zwischen mehreren
Tabellen mappen kann.


\section{Datenbankdefinition}

Wie bereits erwähnt gibt es zwei Möglichkeiten, die Datenbankstruktur und das
dazugehörige Mapping zu definieren. Als Beispiel für die beiden Möglichkeiten
wird jeweils die folgende Beispieldatenbank dienen:

\ul{Tabelle \textbf{authors}:}\\
\textbf{id} \texttt{INTEGER NOT NULL}\\
name \texttt{VARCHAR NOT NULL}

\ul{Tabelle \textbf{books}:}\\
\textbf{id} \texttt{INTEGER NOT NULL}\\
\textit{author\_id} \texttt{INTEGER NOT NULL}\\
title \texttt{VARCHAR NOT NULL}

\ul{Tabelle \textbf{tags}:}\\
\textbf{id} \texttt{INTEGER NOT NULL}\\
tag \texttt{VARCHAR UNIQUE NOT NULL}

\ul{Tabelle \textbf{tags2books}:}\\
\textbf{\textit{tag\_id}} \texttt{INTEGER NOT NULL}\\
\textbf{\textit{book\_id}} \texttt{INTEGER NOT NULL}

\ul{Fremdschl\"ussel-Beziehungen:}\\
books.author\_id $\rightarrow$ authors.id\\
tags2books.tag\_id $\rightarrow$ tags.id\\
tags2books.author\_id $\rightarrow$ authors.id

Bei den Primärschlüsseln in \emph{authors}, \emph{books} und \emph{tags} sollen
darüberhinaus automatisch generierte IDs benutzt werden.

\todotext{Schönes Diagramm für die DB-Struktur einfügen}

\subsection{mapper()-Syntax}

Nutzt man die klassische \emph{mapper()-Syntax} so definiert man Tabellen,
Klassen und Mappings/Relationen nacheinander.
\autoref{lst:dbdef-mapper-tables} zeigt die Definition der Tabellen und
datenbankseitigen Relationen (Fremdschlüssel, Indizes). Im zuvor erzeugten
\texttt{metadata}-Objekt legt SQLAlchemy die Metadaten zu den Tabellen und
Relationen ab. Desweiteren kann man über dieses Objekt die Tabellen in der
Datenbank erstellen (\texttt{metadata.create\_all()}) und auch löschen lassen.
Da die \emph{id}-Spalten als \texttt{Integer} und \texttt{primary\_key}
definiert sind generiert SQLAlchemy automatisch eine automatisch
inkrementierende Spalte - d.h. in PostgreSQL eine Spalte vom Typ \texttt{serial}
und in MySQL eine \texttt{INT}-Spalte mit dem \texttt{AUTO\_INCREMENT}-Attribut.
Damit die Spalten nicht \texttt{NULL} sein dürfen wurde bei allen
nicht-Primärschlüssel-Spalten das \texttt{nullable}-Attribut auf \texttt{False}
gesetzt. Bei den Primärschlüsseln ist dies nicht notwendig, da ein
Primärschlüssel \textit{per definitionem} nicht \texttt{NULL} sein kann.
Ebenfalls in der Tabellendefinition enthalten sind Fremdschlüssel, die mit dem
\texttt{ForeignKey()}-Konstrukt definiert werden, und reguläre Indizes, die mit
\texttt{index=True} definiert werden.

\lstinputlisting[language=Python,label=lst:dbdef-mapper-tables,lastline=30,
caption=Definition der Tabellen]{code/sqlalchemy-def-mapper.py}

In \autoref{lst:dbdef-mapper-classes} werden die Klassen für das Mapping
definiert. Bei diesen Klassen handelt es sich um POPOs\footnote{Plain Old Python
Objects}, die nur von \texttt{object} erben und auch keine anderen Bedingungen
erfüllen müssen - eine komplett leere Klasse reicht bereits aus. Zum Testen und
Debuggen ist es jedoch sinnvoll, die \texttt{\_\_repr\_\_}-Methode zu
implementieren, sodass \texttt{print instanz\_der\_klasse} brauchbare
Informationen anstelle der Speicheradresse ausgibt. Im Beispielcode werden dazu
einfach der Klassename und sowohl die ID als auch die aussagekräftigste Spalte
(Name, Titel, Tagname) verwendet. In einem realen Projekt wäre es darüberhinaus
sinnvoll einen Konstruktor zu erstellen, der häufig genutzten Feldern einen Wert
zuweist, sodass man z.B. \texttt{jquery\_tag = Tag('jquery')} schreiben kann.

\lstinputlisting[language=Python,label=lst:dbdef-mapper-classes,firstline=32,
lastline=43,caption=Definition der Klassen]{code/sqlalchemy-def-mapper.py}

Nachdem Tabellen und Klassen definiert sind müssen sie miteinander verknüpft
werden - bisher sind die Klassen relativ nutzlos.
\autoref{lst:dbdef-mapper-mapping} zeigt den dafür notwendigen Code. Die
\texttt{mapper()}-Funktion nimmt als Argumente als erstes die zu mappende Klasse
und als zweites die dazugehörige Tabelle. Relationen zwischen Tabellen werden
über den \texttt{properties}-Parameter und die \texttt{relationship()}-Funktion
definiert. Diese Funktion benötigt als ersten Parameter das Ziel der Relation.
Um auch vom Zielobjekt aus auf die Relation zugreifen zu können kann man über
den \texttt{backref}-Parameter den Feldnamen angeben, unter dem sie dort
verfügbar sein soll. Sofern man die \emph{backref} konfigurieren will, gibt
man statt eines Strings den Rückgabewert der \texttt{backref()}-Funktion an, die
als ersten Parameter den Feldnamen und danach diverse Konfigurationsparameter
erwartet. Der wohl wichtigste Parameter sowohl von \texttt{relationship()} als
auch \texttt{backref()} ist \texttt{lazy}: Er gibt an, zu welchem Zeitpunkt die
Daten der Relation geladen werden sollen. Standard ist \texttt{True}, was
bedeutet, dass eine SQL-Abfrage abgeschickt wird sobald auf die Relation
zugegriffen wird. Wenn man \texttt{lazy=False} setzt wird die Query, die die
Daten des Objektes selbst lädt, um einen \emph{JOIN} erweitert, sodass beim
Zugriff auf die Relation keine weitere Abfrage mehr notwendig ist - im Beispiel
wurde \texttt{Tag.books} auf \emph{eager loading} (\texttt{lazy=False}) gesetzt,
da es anzunehmen ist, dass man nicht nur ein Tag laden will sondern auch die
Bücher, die dieses Tag haben. Der letzte wichtige Parameter ist
\texttt{secondary} und wird für \emph{Many-To-Many}-Relationen benutzt, um die
Assoziationstabelle anzugeben.

\lstinputlisting[language=Python,label=lst:dbdef-mapper-mapping,firstline=45,
lastline=52,caption=Mapping der Tabellen auf die
Klassen]{code/sqlalchemy-def-mapper.py}


\subsection{Deklarative Syntax}

Die grundlegenden Methoden sind bei der deklarativen Syntax mit denen der
\texttt{mapper()}-Syntax identisch: Relationen werden ebenfalls mit
\texttt{relationship()} und Spalten mit \texttt{Column()} definiert, was man in
\autoref{lst:dbdef-decl} leicht erkennt.
Allerdings sind weder \texttt{mapper()}-Aufrufe noch reine Tabellendefinitionen
notwendig - man definiert einfach eine Klasse, die von der durch
\texttt{declarative\_base()} erzeugten Klasse erbt und Felder mit den
Spaltennamen enthält. im \texttt{Column()}-Aufruf fällt der Spaltenname dafür
weg, da er ja schon durch den Feldnamen angegeben wurde. Der Tabellenname in der
Datenbank wird mit dem "magischen" Feld \texttt{\_\_tablename\_\_} angegeben;
desweiteren können Parameter, die normalerweise an \texttt{mapper()} übergeben
würden, mit \texttt{\_\_mapper\_args\_\_} festgelegt werden.
Da bei Relationen u.U. die referenzierte Klasse bzw. Tabelle noch nicht definiert
wurde ist es auch möglich, ihren Namen als String zu übergeben - dadurch ist es
möglich, im Beispielcode in der Deklaration von \emph{Book} schon die
\emph{Tag}-Klasse und die \emph{tags2books}-Tabelle zu referenzieren obwohl sie
noch nicht definiert wurden.
Ein arbeitssparendes Feature der deklarativen Syntax ist der Konstruktor, den
jede Klasse erhält: Er weist jedes übergebene \textit{keyword argument} dem
gleichnamigen Feld zu, d.h. man kann beispielsweise einen neuen Autor mittels
\texttt{Author(name='Donald Knuth')} anlegen statt erst das Objekt instanziieren
zu müssen und danach \texttt{autor.name} zuzuweisen.

\lstinputlisting[language=Python,label=lst:dbdef-decl,caption=Deklarative
Datenbankdefinition]{code/sqlalchemy-def-decl.py}


\section{Datenbankzugriff}

In der Datenbankdefinition wurde bisher noch keine Datenbank angegeben
geschweige denn eine Verbindung aufgebaut. Damit SQLAlchemy eine Verbindung
aufbauen und für die jeweilige Datenbank gültiges SQL generieren kann, ist es
notwendig, das \emph{metadata}-Objekt mit einer \emph{engine} zu verbinden. Dies
geschieht über die \texttt{bind}-Eigenschaft von \emph{metadata}. In
\autoref{lst:engine-bind} wird eine Verbindung zu \emph{postgresql:///test}
aufgebaut, d.h. zu einer PostgreSQL-Datenbank namens \emph{test}, die ohne
weitere Authentifizierung erreichbar ist. Sofern Benutzername, Passwort oder
andere Parameter notwendig sind, werden sie in derselben Art und Weise
angegeben, die auch bei anderen URLs - z.B. bei Weblinks - üblich ist: \\
\texttt{dialect://user:password@host/dbname[?key=value..]} \\
Der \texttt{echo=True}-Parameter von \texttt{create\_engine()} gibt an, dass
jegliche SQL-Abfragen auf \emph{stdout} ausgegeben werden, was insbesondere bei
der Entwicklung nützlich ist, um beispielsweise erkennen zu können ob man
durch Relationen mit \emph{lazy loading} zusätzliche Abfragen verursacht.
Nachdem \emph{metadata} nun eine \emph{engine} besitzt, können die definierten
Tabellen mit \texttt{metadata.create\_all()} erstellt werden.

\lstinputlisting[language=Python,label=lst:engine-bind,caption=Verbindung zur
Datenbank]{code/sqlalchemy-engine-bind.py}

\subsection{Zugriff via ORM}

Um per ORM auf die Datenbank zugreifen zu können, ist nicht nur die
Datenbankverbindung in Form einer \emph{engine} notwendig, sondern auch eine
\emph{session}. Die dazu notwendige Klasse wird mit der Funktion
\texttt{sessionmaker()} erstellt, die als Parameter die \emph{engine} erwartet.
Ein weiterer Parameter, der in \autoref{lst:session} benutzt wird, ist
\texttt{autocommit}. Wenn \texttt{autocommit} deaktiviert ist, startet
SQLAlchemy automatisch eine Transaktion, sobald auf die Datenbank zugegriffen
wird, sodass man Änderungen mit \texttt{session.commit()} bestätigen bzw. mit
\texttt{session.rollback()} rückgängig machen muss. Es ist nicht zu empfehlen,
\texttt{autocommit} zu aktivieren, da man dann nach Änderungen an einem Objekt
nicht erwarten kann, dass diese sofort in der Datenbank persistiert werden.
Die kann problematisch sein, wenn eine Applikation direkt nach einer Änderung
ein externes Programm aufruft, welches ebenfalls auf die Datenbank zugreift
und die geänderten Daten benutzen soll.

\lstinputlisting[language=Python,label=lst:session,caption=Erstellen der
Session]{code/sqlalchemy-session.py}

Jegliche Änderungen an der Datenbank, die über das ORM durchgeführt werden
sollen, benötigen eine Instanz eines gemappten Objektes.

Wenn man ein neues Objekt in die Datenbank einfügen möchte, erstellt man einfach
eine neue Objektinstanz und fügt es mittels \texttt{session.add(objekt)} der
Session hinzu. Sofern man nicht mit \emph{autocommit} arbeitet ist danach noch
ein Aufruf von \texttt{session.commit()} notwendig, um das Objekt tatsächlich in
der Datenbank zu speichern. Falls das neue Objekt andere noch nicht persistierte
Objekte referenziert, müssen diese nicht separat der Session hinzugefügt werden;
SQLAlchemy persistiert automatisch alle Objekte, die von einem neuen Objekt
referenziert werden. \autoref{lst:orm-add} demonstriert dieses Feature, indem
verschiedene Objekte angelegt werden und auf verschiedene Arten miteinander
verknüpft werden:
Die einfachste Methode ist, einfach dem entsprechenden Feld das zu verknüpfende
Objekt zuzuweisen: \texttt{author=jresig} \\
Im Falle der M:N-Relation \emph{Book.tags} handelt es sich beim
\texttt{tags}-Feld um eine Liste. Daher muss in diesem Fall eine Liste statt
eines einzelnen Objekts zugewiesen oder eine entsprechende Listenoperation
wie \texttt{.add(objekt)} verwendet werden. Da die \emph{Book.tags}-Relation
mit einen \textit{backref} \texttt{Tag.books} definiert wurde, kann
\texttt{jsbook} nun auch über die Liste \texttt{jquery.books} referenziert und
auch verändert werden. Um nun noch ein Tag \emph{javascript} zu erstellen und es
mit dem neuen Buch zu verknüpfen, könnte man es einfach der
\texttt{jsbook.tags}-Liste hinzufügen. Allerdings ist es auch umgekehrt möglich,
indem man das Buch der \texttt{books}-Liste des neuen Tags hinzufügt. Obwohl die
Tag-Instanz nirgends zugewiesen wurde wird sie durch die Relation
\texttt{Tag.books} und die dazugehörige \texttt{Book.tags}-Relation mit dem Buch
verknüpft und daher korrekt persistiert.

\lstinputlisting[language=Python,label=lst:orm-add,caption=Persistieren von
Objekten]{code/sqlalchemy-orm-add.py}

\todotext{Auslesen, filtern, modifizieren, löschen}

\subsection{Lowlevel-Zugriff}

\section{Deklarationsfreies ORM mit SqlSoup}

